
/********************/

// j is column
// k is row

// could put this check in, prob doesnt need it
// if (row > 1 - depth && row < y_max + 2 + depth + y_extra)

// left/right buffer
// index=j+(k+depth-1)*depth

// left index 
// left_snd_buffer(index)=field(chunks(chunk)%field%x_min+x_extra-1+j,k)
// field(chunks(chunk)%field%x_min-j,k)=left_rcv_buffer(index)

// right index
// right_snd_buffer(index)=field(chunks(chunk)%field%x_max+1-j,k)
// field(chunks(chunk)%field%x_max+x_extra+j,k)=right_rcv_buffer(index)

/********************/

// top/bottom buffer
// index=j+depth+(k-1)*(chunks(chunk)%field%x_max+x_extra+(2*depth))

// bottom index
// bottom_snd_buffer(index)=field(j,chunks(chunk)%field%y_min+y_extra-1+k)
// field(j,chunks(chunk)%field%y_min-k)=bottom_rcv_buffer(index)

// top index
// top_snd_buffer(index)=field(j,chunks(chunk)%field%y_max+1-k)
// field(j,chunks(chunk)%field%y_max+y_extra+k)=top_rcv_buffer(index)

/********************/

// for left/right
#define VERT_IDX                        \
    ((column - 1) +                     \
    ((row    - 1) + depth - 1)*depth)+1
// for top/bottom
#define HORZ_IDX                        \
    ((column - 1) + depth +             \
    ((row    - 0) - 0)*(x_max + x_extra + 2*depth))-1

typedef void (*pack_func_t)(int x_min,int x_max,int y_min,int y_max,
     int x_extra, int y_extra,
          double* array,
          double* left_buffer,
    const int depth);

// special ones for 2d indexing as used in buffer packing
#undef __kernel_indexes
#define __kernel_indexes                    \
    const int column = threadIdx.x + blockIdx.x*blockDim.x;          \
    const int row = threadIdx.y + blockIdx.y*blockDim.y;

#undef THARR2D
#define THARR2D(x_offset, y_offset, big_row)        \
    (                                               \
      column                      /* horizontal  */ \
    + row*(x_max + 4)             /* vertical    */ \
    + (x_offset)                  /* horz offset */ \
    + (y_offset)*(x_max + 4)      /* vert offset */ \
    + (big_row)*(row + (y_offset))/* big row   */   \
    )

__global__ void device_packleftBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
      double* array,
      double* left_buffer,
const int depth)
{
    __kernel_indexes;

    if (row >= (y_min + 1) - depth && row <= (y_max + 1) + y_extra + depth)
    {
        left_buffer[VERT_IDX] = array[THARR2D((x_min + 1) + x_extra, 0, x_extra)];
    }
}

__global__ void device_unpackleftBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
      double* array,
      double* left_buffer,
const int depth)
{
    __kernel_indexes;

    if (row >= (y_min + 1) - depth && row <= (y_max + 1) + y_extra + depth)
    {
        array[THARR2D(1 - 2*column, 0, x_extra)] = left_buffer[VERT_IDX];
    }
}

/************************************************************/

__global__ void device_packrightBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
      double* array,
      double* right_buffer,
const int depth)
{
    __kernel_indexes;

    if (row >= (y_min + 1) - depth && row <= (y_max + 1) + y_extra + depth)
    {
        right_buffer[VERT_IDX] = array[THARR2D((x_max + 1) - 2*column, 0, x_extra)];
    }
}

__global__ void device_unpackrightBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
      double* array,
      double* right_buffer,
const int depth)
{
    __kernel_indexes;

    if (row >= (y_min + 1) - depth && row <= (y_max + 1) + y_extra + depth)
    {
        array[THARR2D((x_max + 1) + x_extra + 1, 0, x_extra)] = right_buffer[VERT_IDX];
    }
}

/************************************************************/

__global__ void device_packbottomBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
            double* array,
            double* bottom_buffer,
const int depth)
{
    __kernel_indexes;

    if (column >= (x_min + 1) - depth && column <= (x_max + 1) + x_extra + depth)
    {
        bottom_buffer[HORZ_IDX] = array[THARR2D(0, (y_min + 1) + y_extra, x_extra)];
    }
}

__global__ void device_unpackbottomBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
            double* array,
            double* bottom_buffer,
const int depth)
{
    __kernel_indexes;

    if (column >= (x_min + 1) - depth && column <= (x_max + 1) + x_extra + depth)
    {
        array[THARR2D(0, 1 - 2*row, x_extra)] = bottom_buffer[HORZ_IDX];
    }
}

/************************************************************/

__global__ void device_packtopBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
            double* array,
            double* top_buffer,
const int depth)
{
    __kernel_indexes;

    if (column >= (x_min + 1) - depth && column <= (x_max + 1) + x_extra + depth)
    {
        top_buffer[HORZ_IDX] = array[THARR2D(0, (y_max + 1) - 2*row, x_extra)];
    }
}

__global__ void device_unpacktopBuffer
(int x_min,int x_max,int y_min,int y_max,
 int x_extra, int y_extra,
            double* array,
            double* top_buffer,
const int depth)
{
    __kernel_indexes;

    if (column >= (x_min + 1) - depth && column <= (x_max + 1) + x_extra + depth)
    {
        array[THARR2D(0, (y_max + 1) + y_extra + 1, x_extra)] = top_buffer[HORZ_IDX];
    }
}

